---
title: "Simulating Tree Height and Crown Diameter for Forest Monitoring"
author: "Adam J. Eichenwald"
date: "`r Sys.Date()`"
output: html_document
---

## Introduction

In forest ecology, understanding the structural characteristics of trees, such as height and crown diameter, is crucial for monitoring ecosystem health and estimating carbon storage capacity. Using allometric equations from Hulshof et al. (2015) and Jucker et al. (2017), we can simulate tree heights and crown diameters for a given set of stem diameters at breast height (DBH) to approximate forest canopy structure. This simulation will assign tree types (deciduous or evergreen) and use these equations to estimate the structural attributes needed for remote sensing applications.

## Methods

### Data and Tree Type Assignment

We start with a vector of DBH values representing individual trees. Each tree is assigned a type (deciduous or evergreen) based on a user-defined proportion, allowing flexibility in simulating different forest compositions.

### Allometric Equations

The following equations were used to estimate tree height and crown diameter:

1. **Height-DBH Allometry (Hulshof et al., 2015)**:
   For estimating tree height \(H\), we use species-specific allometric equations. For deciduous trees, the equation is:
   
   \[
   H = (2.35 \times D)^{0.53}
   \]
   
   For evergreen trees, the equation is:
   
   \[
   H = (3.25 \times D)^{0.60}
   \]
   
   where \(D\) is the DBH in centimeters (Hulshof et al., 2015).

2. **Crown Diameter-Height-DBH Allometry (Jucker et al., 2017)**:
   To estimate crown diameter \(CA\), we use a biome-specific model:
   
   \[
   CA = a \times (H \times D)^b \times \exp\left(\frac{g^2}{2}\right)
   \]
   
   where \(a\), \(b\), and \(g\) are biome-specific parameters. Here, we use parameters from the temperate biome (biome 0), with \(a = 0.557\), \(b = 0.809\), and \(g = 0.056\) (Jucker et al., 2017).

## R Code

The following R code performs the simulation:

```{r}

# Define the DBH vector in cm
dbh <- c(10, 15, 20, 25, 30, 35)  # Example DBH values

# Function to assign tree types based on a probability
assign_tree_type <- function(dbh, p_evergreen = 0.5) {
  tree_types <- sample(c("evergreen", "deciduous"), size = length(dbh), 
                       replace = TRUE, prob = c(p_evergreen, 1 - p_evergreen))
  return(tree_types)
}

# Assign types to each tree in the DBH vector
tree_types <- assign_tree_type(dbh, p_evergreen = 0.6)

# Coefficients for height-diameter allometry (Hulshof et al., 2015)
a_evergreen <- 3.25
b_evergreen <- 0.60
a_deciduous <- 2.35
b_deciduous <- 0.53

# Calculate height based on tree type
calculate_height <- function(dbh, type) {
  if (type == "evergreen") {
    return((a_evergreen * dbh)^b_evergreen)
  } else {
    return((a_deciduous * dbh)^b_deciduous)
  }
}

# Calculate heights for each tree
heights <- mapply(calculate_height, dbh, tree_types)

# Parameters for the biome-specific crown diameter equation (Jucker et al., 2017)
a_biome <- 0.557  # for biome 0
b_biome <- 0.809
g_biome <- 0.056

# Function to calculate crown diameter (CA) based on height (H) and DBH
calculate_crown_diameter <- function(H, dbh) {
  # Correct crown diameter formula: solving for CA (diameter, not area)
  CA <- ((dbh / (a_biome * exp(g_biome / 2)))^(1 / b_biome)) / H
  # Convert from crown area to crown diameter (d_CA)
  d_CA <- 2 * sqrt(CA / pi)
  return(d_CA)
}

# Calculate crown diameter (CA) for each tree
crown_diameters <- mapply(calculate_crown_diameter, heights, dbh)

# Compile results into a data frame
forest_data <- data.frame(
  DBH = dbh,
  Type = tree_types,
  Height = heights,
  Crown_Diameter = crown_diameters
)

# Display the simulated data
print(forest_data)
```
### Mapping Tree Positions and Determining Visibility

In the previous section, we calculated the tree heights and crown diameters from the trees' DBH (Diameter at Breast Height). This step provided the necessary attributes to represent each tree's size and canopy spread. With this information, we can simulate the spatial arrangement of trees in the forest plot and assess how their canopies overlap, which is critical for determining their visibility from above.

#### Step 1: Simulating Tree Positions

We first simulate the positions of the trees in a 100x100 meter plot. The assumption here is that the trees are randomly distributed within this area. For each tree, we generate random X and Y coordinates between 0 and 100 meters. This random distribution is based on the number of trees in the dataset and ensures that the trees are spatially distributed across the plot.

#### Step 2: Creating Canopy Buffers

For each tree, we create a circular buffer around its position, where the radius of the buffer is half of the tree’s crown diameter. The crown diameter, derived from the DBH, represents the extent of the tree's canopy. This buffer represents the spatial area that the tree’s canopy covers and allows us to assess interactions between trees in terms of their spatial overlap. By creating buffers, we essentially map out the area influenced by each tree, which is necessary for the next steps in determining visibility.

#### Step 3: Checking for Overlap and Containment

Once the buffers are created, the next step is to determine which trees are overtopped by others. We do this by checking if the buffer of one tree is completely contained within the buffer of another tree. A tree can be considered "overtopped" if its buffer is fully enclosed by the buffer of another tree. The rationale behind this is that if one tree’s canopy entirely covers another tree’s canopy, the covered tree is less likely to be visible from above.

#### Step 4: Comparing Tree Heights

When we identify that a tree’s buffer is contained within another tree's buffer, we perform a height comparison. This is crucial: even if one tree is contained within another, its visibility depends on whether the tree above it is taller. If the containing tree has a greater height, the contained tree is classified as "Invisible," indicating that it is overshadowed by the taller tree's canopy and will not be visible from above. On the other hand, if the containing tree is shorter or of equal height, the contained tree remains "Visible."

#### Why This Approach?

This approach models tree visibility based on canopy overlap and height, which are the key factors in determining which trees are visible from remote sensing or aerial surveys. Trees with larger, taller canopies are more likely to overshadow shorter, smaller trees, making them invisible in a canopy-based survey. By classifying trees as "Visible" or "Invisible" based on this logic, we can simulate a more realistic forest environment where visibility is determined by the physical structure of the trees and their relative sizes. This step ensures that we account for both spatial relationships (canopy overlap) and tree size (height) when determining visibility.

```{r}

# Number of trees
n_trees <- length(forest_data$DBH)

# Randomly assign tree coordinates (assuming a 100x100 meter plot)
tree_x <- runif(n_trees, 0, 100)  # Random X coordinates between 0 and 100
tree_y <- runif(n_trees, 0, 100)  # Random Y coordinates between 0 and 100

# Create a data frame for the trees' positions
tree_coords <- data.frame(
  x = tree_x,
  y = tree_y,
  Height = forest_data$Height,
  Crown_Diameter = forest_data$Crown_Diameter,
  DBH = forest_data$DBH
)

# Convert to an sf object with a CRS in meters (EPSG:3857)
tree_coords_sf <- st_as_sf(tree_coords, coords = c("x", "y"), crs = 3857)

# Create buffers based on crown diameter
tree_coords_sf <- tree_coords_sf %>%
  st_buffer(dist = tree_coords_sf$Crown_Diameter / 2)

# Initialize a column for visibility classification
tree_coords_sf$Visibility <- "Visible"

# Compute which buffers contain other buffers (without self-containment)
tree_coords_sf$within <- st_within(tree_coords_sf, tree_coords_sf, sparse = FALSE, remove_self = TRUE)

# Function to check containment and update visibility
for (i in 1:n_trees) {
  # Get the current tree's buffer
  current_buffer <- tree_coords_sf$geometry[i]
  
  # Find the trees whose buffers completely contain the current tree's buffer
  containing_trees <- which(tree_coords_sf$within[i, ])  # The row for current tree, columns where TRUE
  
  # If it is contained by any other tree, check height comparison
  if (length(containing_trees) > 0) {
    # Check if any containing tree has a larger height than the current tree
    for (tree_index in containing_trees) {
      if (tree_coords_sf$Height[tree_index] > tree_coords_sf$Height[i]) {
        tree_coords_sf$Visibility[i] <- "Invisible"
      }
    }
  }
}

print(tree_coords_sf%>%
  select(-within)%>%
    data.frame()%>%
    select(-geometry))
plot(tree_coords_sf[1])
```
## Simulating Forests with Pareto Distribution and Visibility Classification

In the previous sections, we established a method for calculating tree height and crown diameter from DBH, as well as determining tree visibility based on canopy overlap and height comparisons. With this framework in place, we can now proceed to simulate entire forest plots where tree size and abundance follow a Pareto or power law distribution. This type of distribution is commonly observed in forest ecosystems, where a few large, dominant trees make up the majority of the biomass, while the majority of trees are smaller. By using this distribution, we can model realistic forest dynamics, where tree size varies according to a power law and examine the resulting forest structure.

In our simulation, tree sizes and abundance are generated using a Pareto distribution. This distribution has two key parameters: the location (xmin) and the shape parameter $\alpha$. The location parameter, xmin, sets the minimum tree size in the simulation, and in this case, we set xmin to 3 cm to reflect the minimum size of trees that are relevant for the analysis. The shape parameter, $\alpha$, governs the steepness of the distribution—larger values of $\alpha$ indicate a stronger dominance of small trees, with fewer larger trees. By randomly assigning different values of $\alpha$ to each forest simulation, we can explore how varying tree size distributions impact the overall structure of the forest.

Once tree sizes are generated using the Pareto distribution, we calculate the corresponding tree heights and crown diameters, which are based on the DBH values. These attributes are crucial for modeling tree canopy structure, as they will determine the spatial arrangement of trees and how they overlap with each other. Using this information, we simulate multiple forest plots, each with a different combination of tree sizes and abundance patterns.

After the trees are generated and their sizes determined, we next apply a method for classifying which trees would be visible from a remote sensing platform. In real-world forests, smaller trees are often obscured by the larger trees that overshadow them. This means that only a subset of trees, typically the larger ones, will be visible in remote sensing imagery. By using the height and canopy overlap rules established earlier, we classify each tree as either "Visible" or "Invisible." A tree is considered visible if it is not overtopped by taller trees or if its canopy is not completely covered by the crowns of neighboring trees. This classification process helps us identify which trees would be detectable by remote sensing, which is crucial for understanding how tree visibility influences data collection in forest monitoring.

With the simulated forests in place and trees classified as visible or invisible, we can now test methods for recovering forest distribution and abundance from incomplete remote sensing data. The overtopping problem—where smaller trees are hidden by the canopy of larger trees—is a common challenge in remote sensing surveys. By simulating multiple forests with different values for alpha and tree size distributions, we can explore how the detectability of trees changes with forest structure. This allows us to evaluate different methods for estimating the full forest distribution and tree abundance, even when some trees are not visible due to canopy overlap.

This simulation framework provides a powerful tool for understanding the dynamics of forest structure and tree visibility. By generating many different forest scenarios, we can better understand the challenges and limitations of remote sensing in forest monitoring. Furthermore, the ability to simulate forests with varying alpha values and tree size distributions allows us to test a wide range of hypotheses and strategies for improving the recovery of forest data in the presence of incomplete information.

In the next section, we will explore how to simulate forests with different Pareto distributions and use these simulations to test recovery methods for forest structure and tree abundance.
